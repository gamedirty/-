设计模式相关

越抽象，扩展性和使用都会更好。越抽象，兼容性就越好。


##设计模式遵循的几个原则
####单一职责原则
一个类，一个对象尽量包含一些高度相关的属性和方法，类的设计职责尽量单一，可以方便复用和扩展，因为职责单一就可以复用的时候就可以去找你需要的功能，而不必因为类设计的不够单一职责而引入了你并不需要的功能。

设计类的时候尽量单一功能集中起来，不要让一个类什么都能干，方法也是这样。
####开闭原则
对扩展开放，对修改封闭。面向接口设计方法，并提供相关的设置方法。面向抽象设计方法和类,修改的话不需要修改之前的类的具体内容，只需要针对抽象设计一个不同的实现就可以了。
####李氏替换原则
对于任何的子类继承自父类，如果一个方法可以针对父类使用，那么也一定对于子类是通用的。子类应该满足父类的一切应用场景，其实也是一种抽象，对抽象有效，则对抽象的实现也需要有效。自定义控件的view绘制，子类需要实现onmeasure  onlayout  ondraw方法等，window依赖view父类，子类也实现了父类的必要方法，所有window也可以使用view的子类来绘制。
####依赖倒置原则
依赖应该依赖接口，不应该依赖具体的实现类，不应该依赖具体的实现细节，依赖通过抽象发生，不要依赖实现。
####接口隔离原则
类之间的耦合应该面向足够高的抽象实现，抽象度应该尽可能的高，通过接口来更好抽象一系列的类。
####迪米特原则
LeastKnowledgePrinciple 模块的依赖应该极可能少，不要依赖不相干的模块。这个应该和单一职责原则结合起来。


##设计模式
####单例模式
即全局只有一个类的实例，静态内部类
public class Singleton{
private Singleton(){}

public static Singleton getInstance(){
return SingletoHandler.instance;
}

private static class SingletoHandler{

private static Singleton instance = new Singleton();

}

}

全局只有一个实例，适用于经常使用同一个对象。频繁创建和销毁的对象。

####建造者模式解决
适合建造一些过于复杂的对象。一个对象有很多的属性配置，不要使用对象直接设置这些属性，会暴露对象里很多的细节，建造者对于原始对象是独立的。

####原型模式
原型模式主要clone接口实现，即对对象进行拷贝，对象拷贝分浅拷贝和深拷贝，浅拷贝只是把对象所有的元素都重新赋值给新的对象，深拷贝是吧对象的对象属性也再进行了一次拷贝。